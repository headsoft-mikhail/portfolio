// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TelemetryCtrl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TelemetryCtrl_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TelemetryCtrl_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TelemetryCtrl_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TelemetryCtrl_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TelemetryCtrl_2eproto;
namespace TELEMETRY_CTRL {
class AirTelemetry;
class AirTelemetryDefaultTypeInternal;
extern AirTelemetryDefaultTypeInternal _AirTelemetry_default_instance_;
class Ctrl;
class CtrlDefaultTypeInternal;
extern CtrlDefaultTypeInternal _Ctrl_default_instance_;
class MRTelemetry;
class MRTelemetryDefaultTypeInternal;
extern MRTelemetryDefaultTypeInternal _MRTelemetry_default_instance_;
class Navigation;
class NavigationDefaultTypeInternal;
extern NavigationDefaultTypeInternal _Navigation_default_instance_;
class Orientation;
class OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class SubscriberList;
class SubscriberListDefaultTypeInternal;
extern SubscriberListDefaultTypeInternal _SubscriberList_default_instance_;
class Telemetry;
class TelemetryDefaultTypeInternal;
extern TelemetryDefaultTypeInternal _Telemetry_default_instance_;
class TelemetryList;
class TelemetryListDefaultTypeInternal;
extern TelemetryListDefaultTypeInternal _TelemetryList_default_instance_;
}  // namespace TELEMETRY_CTRL
PROTOBUF_NAMESPACE_OPEN
template<> ::TELEMETRY_CTRL::AirTelemetry* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::AirTelemetry>(Arena*);
template<> ::TELEMETRY_CTRL::Ctrl* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::Ctrl>(Arena*);
template<> ::TELEMETRY_CTRL::MRTelemetry* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::MRTelemetry>(Arena*);
template<> ::TELEMETRY_CTRL::Navigation* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::Navigation>(Arena*);
template<> ::TELEMETRY_CTRL::Orientation* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::Orientation>(Arena*);
template<> ::TELEMETRY_CTRL::SubscriberList* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::SubscriberList>(Arena*);
template<> ::TELEMETRY_CTRL::Telemetry* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::Telemetry>(Arena*);
template<> ::TELEMETRY_CTRL::TelemetryList* Arena::CreateMaybeMessage<::TELEMETRY_CTRL::TelemetryList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TELEMETRY_CTRL {

enum TelemetryCtrlMsgType : int {
  CtrlMsgType_Telemetry = 0,
  CtrlMsgType_Subscribe = 1,
  CtrlMsgType_Unsubscribe = 2
};
bool TelemetryCtrlMsgType_IsValid(int value);
constexpr TelemetryCtrlMsgType TelemetryCtrlMsgType_MIN = CtrlMsgType_Telemetry;
constexpr TelemetryCtrlMsgType TelemetryCtrlMsgType_MAX = CtrlMsgType_Unsubscribe;
constexpr int TelemetryCtrlMsgType_ARRAYSIZE = TelemetryCtrlMsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TelemetryCtrlMsgType_descriptor();
template<typename T>
inline const std::string& TelemetryCtrlMsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TelemetryCtrlMsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TelemetryCtrlMsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TelemetryCtrlMsgType_descriptor(), enum_t_value);
}
inline bool TelemetryCtrlMsgType_Parse(
    const std::string& name, TelemetryCtrlMsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TelemetryCtrlMsgType>(
    TelemetryCtrlMsgType_descriptor(), name, value);
}
enum Error : int {
  Error_NoError = 0,
  Error_General = 1
};
bool Error_IsValid(int value);
constexpr Error Error_MIN = Error_NoError;
constexpr Error Error_MAX = Error_General;
constexpr int Error_ARRAYSIZE = Error_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Error_descriptor();
template<typename T>
inline const std::string& Error_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Error>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Error_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Error_descriptor(), enum_t_value);
}
inline bool Error_Parse(
    const std::string& name, Error* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Error>(
    Error_descriptor(), name, value);
}
enum AutopilotMode : int {
  AutopilotMode_GPS = 0,
  AutopilotMode_FailSafe = 1,
  AutopilotMode_ATT = 2
};
bool AutopilotMode_IsValid(int value);
constexpr AutopilotMode AutopilotMode_MIN = AutopilotMode_GPS;
constexpr AutopilotMode AutopilotMode_MAX = AutopilotMode_ATT;
constexpr int AutopilotMode_ARRAYSIZE = AutopilotMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AutopilotMode_descriptor();
template<typename T>
inline const std::string& AutopilotMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AutopilotMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AutopilotMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AutopilotMode_descriptor(), enum_t_value);
}
inline bool AutopilotMode_Parse(
    const std::string& name, AutopilotMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AutopilotMode>(
    AutopilotMode_descriptor(), name, value);
}
enum FixType : int {
  FixType_2D = 0,
  FixType_3D = 1
};
bool FixType_IsValid(int value);
constexpr FixType FixType_MIN = FixType_2D;
constexpr FixType FixType_MAX = FixType_3D;
constexpr int FixType_ARRAYSIZE = FixType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FixType_descriptor();
template<typename T>
inline const std::string& FixType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FixType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FixType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FixType_descriptor(), enum_t_value);
}
inline bool FixType_Parse(
    const std::string& name, FixType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FixType>(
    FixType_descriptor(), name, value);
}
// ===================================================================

class Navigation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.Navigation) */ {
 public:
  Navigation();
  virtual ~Navigation();

  Navigation(const Navigation& from);
  Navigation(Navigation&& from) noexcept
    : Navigation() {
    *this = ::std::move(from);
  }

  inline Navigation& operator=(const Navigation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Navigation& operator=(Navigation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Navigation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Navigation* internal_default_instance() {
    return reinterpret_cast<const Navigation*>(
               &_Navigation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Navigation* other);
  friend void swap(Navigation& a, Navigation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Navigation* New() const final {
    return CreateMaybeMessage<Navigation>(nullptr);
  }

  Navigation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Navigation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Navigation& from);
  void MergeFrom(const Navigation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Navigation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.Navigation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double latitude = 1;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  double latitude() const;
  void set_latitude(double value);

  // required double longitude = 2;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  double longitude() const;
  void set_longitude(double value);

  // required float altitude = 3;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  float altitude() const;
  void set_altitude(float value);

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.Navigation)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double latitude_;
  double longitude_;
  float altitude_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class Orientation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.Orientation) */ {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Orientation& operator=(Orientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Orientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Orientation* other);
  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Orientation* New() const final {
    return CreateMaybeMessage<Orientation>(nullptr);
  }

  Orientation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Orientation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.Orientation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float roll = 1;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  float roll() const;
  void set_roll(float value);

  // required float pitch = 2;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // required float yaw = 3;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.Orientation)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float roll_;
  float pitch_;
  float yaw_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class AirTelemetry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.AirTelemetry) */ {
 public:
  AirTelemetry();
  virtual ~AirTelemetry();

  AirTelemetry(const AirTelemetry& from);
  AirTelemetry(AirTelemetry&& from) noexcept
    : AirTelemetry() {
    *this = ::std::move(from);
  }

  inline AirTelemetry& operator=(const AirTelemetry& from) {
    CopyFrom(from);
    return *this;
  }
  inline AirTelemetry& operator=(AirTelemetry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AirTelemetry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AirTelemetry* internal_default_instance() {
    return reinterpret_cast<const AirTelemetry*>(
               &_AirTelemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AirTelemetry* other);
  friend void swap(AirTelemetry& a, AirTelemetry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AirTelemetry* New() const final {
    return CreateMaybeMessage<AirTelemetry>(nullptr);
  }

  AirTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AirTelemetry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AirTelemetry& from);
  void MergeFrom(const AirTelemetry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AirTelemetry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.AirTelemetry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float altBaro = 1;
  bool has_altbaro() const;
  void clear_altbaro();
  static const int kAltBaroFieldNumber = 1;
  float altbaro() const;
  void set_altbaro(float value);

  // optional float airSpeed = 2;
  bool has_airspeed() const;
  void clear_airspeed();
  static const int kAirSpeedFieldNumber = 2;
  float airspeed() const;
  void set_airspeed(float value);

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.AirTelemetry)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float altbaro_;
  float airspeed_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class MRTelemetry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.MRTelemetry) */ {
 public:
  MRTelemetry();
  virtual ~MRTelemetry();

  MRTelemetry(const MRTelemetry& from);
  MRTelemetry(MRTelemetry&& from) noexcept
    : MRTelemetry() {
    *this = ::std::move(from);
  }

  inline MRTelemetry& operator=(const MRTelemetry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MRTelemetry& operator=(MRTelemetry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MRTelemetry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MRTelemetry* internal_default_instance() {
    return reinterpret_cast<const MRTelemetry*>(
               &_MRTelemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MRTelemetry* other);
  friend void swap(MRTelemetry& a, MRTelemetry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MRTelemetry* New() const final {
    return CreateMaybeMessage<MRTelemetry>(nullptr);
  }

  MRTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MRTelemetry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MRTelemetry& from);
  void MergeFrom(const MRTelemetry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MRTelemetry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.MRTelemetry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float batteryVoltage = 1;
  bool has_batteryvoltage() const;
  void clear_batteryvoltage();
  static const int kBatteryVoltageFieldNumber = 1;
  float batteryvoltage() const;
  void set_batteryvoltage(float value);

  // optional .TELEMETRY_CTRL.AutopilotMode autopilotMode = 2;
  bool has_autopilotmode() const;
  void clear_autopilotmode();
  static const int kAutopilotModeFieldNumber = 2;
  ::TELEMETRY_CTRL::AutopilotMode autopilotmode() const;
  void set_autopilotmode(::TELEMETRY_CTRL::AutopilotMode value);

  // optional uint32 batteryChargePercent = 3;
  bool has_batterychargepercent() const;
  void clear_batterychargepercent();
  static const int kBatteryChargePercentFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::uint32 batterychargepercent() const;
  void set_batterychargepercent(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.MRTelemetry)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float batteryvoltage_;
  int autopilotmode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 batterychargepercent_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class Telemetry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.Telemetry) */ {
 public:
  Telemetry();
  virtual ~Telemetry();

  Telemetry(const Telemetry& from);
  Telemetry(Telemetry&& from) noexcept
    : Telemetry() {
    *this = ::std::move(from);
  }

  inline Telemetry& operator=(const Telemetry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Telemetry& operator=(Telemetry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Telemetry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Telemetry* internal_default_instance() {
    return reinterpret_cast<const Telemetry*>(
               &_Telemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Telemetry* other);
  friend void swap(Telemetry& a, Telemetry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Telemetry* New() const final {
    return CreateMaybeMessage<Telemetry>(nullptr);
  }

  Telemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Telemetry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Telemetry& from);
  void MergeFrom(const Telemetry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Telemetry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.Telemetry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TELEMETRY_CTRL.Navigation gpsNavigation = 3;
  bool has_gpsnavigation() const;
  void clear_gpsnavigation();
  static const int kGpsNavigationFieldNumber = 3;
  const ::TELEMETRY_CTRL::Navigation& gpsnavigation() const;
  ::TELEMETRY_CTRL::Navigation* release_gpsnavigation();
  ::TELEMETRY_CTRL::Navigation* mutable_gpsnavigation();
  void set_allocated_gpsnavigation(::TELEMETRY_CTRL::Navigation* gpsnavigation);

  // optional .TELEMETRY_CTRL.Orientation orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  const ::TELEMETRY_CTRL::Orientation& orientation() const;
  ::TELEMETRY_CTRL::Orientation* release_orientation();
  ::TELEMETRY_CTRL::Orientation* mutable_orientation();
  void set_allocated_orientation(::TELEMETRY_CTRL::Orientation* orientation);

  // optional .TELEMETRY_CTRL.AirTelemetry AirTelemetry = 7;
  bool has_airtelemetry() const;
  void clear_airtelemetry();
  static const int kAirTelemetryFieldNumber = 7;
  const ::TELEMETRY_CTRL::AirTelemetry& airtelemetry() const;
  ::TELEMETRY_CTRL::AirTelemetry* release_airtelemetry();
  ::TELEMETRY_CTRL::AirTelemetry* mutable_airtelemetry();
  void set_allocated_airtelemetry(::TELEMETRY_CTRL::AirTelemetry* airtelemetry);

  // optional .TELEMETRY_CTRL.MRTelemetry mrTelemetry = 8;
  bool has_mrtelemetry() const;
  void clear_mrtelemetry();
  static const int kMrTelemetryFieldNumber = 8;
  const ::TELEMETRY_CTRL::MRTelemetry& mrtelemetry() const;
  ::TELEMETRY_CTRL::MRTelemetry* release_mrtelemetry();
  ::TELEMETRY_CTRL::MRTelemetry* mutable_mrtelemetry();
  void set_allocated_mrtelemetry(::TELEMETRY_CTRL::MRTelemetry* mrtelemetry);

  // required uint32 boardId = 1;
  bool has_boardid() const;
  void clear_boardid();
  static const int kBoardIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 boardid() const;
  void set_boardid(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 unix_time = 2;
  bool has_unix_time() const;
  void clear_unix_time();
  static const int kUnixTimeFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 unix_time() const;
  void set_unix_time(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional float gps_course = 5;
  bool has_gps_course() const;
  void clear_gps_course();
  static const int kGpsCourseFieldNumber = 5;
  float gps_course() const;
  void set_gps_course(float value);

  // optional float gps_speed = 6;
  bool has_gps_speed() const;
  void clear_gps_speed();
  static const int kGpsSpeedFieldNumber = 6;
  float gps_speed() const;
  void set_gps_speed(float value);

  // optional .TELEMETRY_CTRL.FixType fixType = 9;
  bool has_fixtype() const;
  void clear_fixtype();
  static const int kFixTypeFieldNumber = 9;
  ::TELEMETRY_CTRL::FixType fixtype() const;
  void set_fixtype(::TELEMETRY_CTRL::FixType value);

  // optional uint32 satellitesCount = 10;
  bool has_satellitescount() const;
  void clear_satellitescount();
  static const int kSatellitesCountFieldNumber = 10;
  ::PROTOBUF_NAMESPACE_ID::uint32 satellitescount() const;
  void set_satellitescount(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional float mag_course = 11;
  bool has_mag_course() const;
  void clear_mag_course();
  static const int kMagCourseFieldNumber = 11;
  float mag_course() const;
  void set_mag_course(float value);

  // optional uint32 servo_angle = 12;
  bool has_servo_angle() const;
  void clear_servo_angle();
  static const int kServoAngleFieldNumber = 12;
  ::PROTOBUF_NAMESPACE_ID::uint32 servo_angle() const;
  void set_servo_angle(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.Telemetry)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::TELEMETRY_CTRL::Navigation* gpsnavigation_;
  ::TELEMETRY_CTRL::Orientation* orientation_;
  ::TELEMETRY_CTRL::AirTelemetry* airtelemetry_;
  ::TELEMETRY_CTRL::MRTelemetry* mrtelemetry_;
  ::PROTOBUF_NAMESPACE_ID::uint32 boardid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unix_time_;
  float gps_course_;
  float gps_speed_;
  int fixtype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 satellitescount_;
  float mag_course_;
  ::PROTOBUF_NAMESPACE_ID::uint32 servo_angle_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class TelemetryList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.TelemetryList) */ {
 public:
  TelemetryList();
  virtual ~TelemetryList();

  TelemetryList(const TelemetryList& from);
  TelemetryList(TelemetryList&& from) noexcept
    : TelemetryList() {
    *this = ::std::move(from);
  }

  inline TelemetryList& operator=(const TelemetryList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryList& operator=(TelemetryList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TelemetryList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TelemetryList* internal_default_instance() {
    return reinterpret_cast<const TelemetryList*>(
               &_TelemetryList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TelemetryList* other);
  friend void swap(TelemetryList& a, TelemetryList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TelemetryList* New() const final {
    return CreateMaybeMessage<TelemetryList>(nullptr);
  }

  TelemetryList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TelemetryList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TelemetryList& from);
  void MergeFrom(const TelemetryList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.TelemetryList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TELEMETRY_CTRL.Telemetry list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::TELEMETRY_CTRL::Telemetry* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TELEMETRY_CTRL::Telemetry >*
      mutable_list();
  const ::TELEMETRY_CTRL::Telemetry& list(int index) const;
  ::TELEMETRY_CTRL::Telemetry* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TELEMETRY_CTRL::Telemetry >&
      list() const;

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.TelemetryList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TELEMETRY_CTRL::Telemetry > list_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class SubscriberList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.SubscriberList) */ {
 public:
  SubscriberList();
  virtual ~SubscriberList();

  SubscriberList(const SubscriberList& from);
  SubscriberList(SubscriberList&& from) noexcept
    : SubscriberList() {
    *this = ::std::move(from);
  }

  inline SubscriberList& operator=(const SubscriberList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscriberList& operator=(SubscriberList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SubscriberList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscriberList* internal_default_instance() {
    return reinterpret_cast<const SubscriberList*>(
               &_SubscriberList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SubscriberList* other);
  friend void swap(SubscriberList& a, SubscriberList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscriberList* New() const final {
    return CreateMaybeMessage<SubscriberList>(nullptr);
  }

  SubscriberList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SubscriberList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SubscriberList& from);
  void MergeFrom(const SubscriberList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriberList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.SubscriberList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 boardId = 1;
  int boardid_size() const;
  void clear_boardid();
  static const int kBoardIdFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 boardid(int index) const;
  void set_boardid(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_boardid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      boardid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_boardid();

  // optional bool isSubscribeToAll = 2 [default = false];
  bool has_issubscribetoall() const;
  void clear_issubscribetoall();
  static const int kIsSubscribeToAllFieldNumber = 2;
  bool issubscribetoall() const;
  void set_issubscribetoall(bool value);

  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.SubscriberList)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > boardid_;
  bool issubscribetoall_;
  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// -------------------------------------------------------------------

class Ctrl :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TELEMETRY_CTRL.Ctrl) */ {
 public:
  Ctrl();
  virtual ~Ctrl();

  Ctrl(const Ctrl& from);
  Ctrl(Ctrl&& from) noexcept
    : Ctrl() {
    *this = ::std::move(from);
  }

  inline Ctrl& operator=(const Ctrl& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ctrl& operator=(Ctrl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ctrl& default_instance();

  enum CommandDataCase {
    kTelemetryList = 3,
    kSubscriberList = 4,
    COMMANDDATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ctrl* internal_default_instance() {
    return reinterpret_cast<const Ctrl*>(
               &_Ctrl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Ctrl* other);
  friend void swap(Ctrl& a, Ctrl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ctrl* New() const final {
    return CreateMaybeMessage<Ctrl>(nullptr);
  }

  Ctrl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ctrl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ctrl& from);
  void MergeFrom(const Ctrl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ctrl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TELEMETRY_CTRL.Ctrl";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_TelemetryCtrl_2eproto);
    return ::descriptor_table_TelemetryCtrl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TELEMETRY_CTRL.TelemetryCtrlMsgType msgType = 1;
  bool has_msgtype() const;
  void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  ::TELEMETRY_CTRL::TelemetryCtrlMsgType msgtype() const;
  void set_msgtype(::TELEMETRY_CTRL::TelemetryCtrlMsgType value);

  // optional .TELEMETRY_CTRL.Error error = 2 [default = Error_NoError];
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  ::TELEMETRY_CTRL::Error error() const;
  void set_error(::TELEMETRY_CTRL::Error value);

  // optional .TELEMETRY_CTRL.TelemetryList telemetryList = 3;
  bool has_telemetrylist() const;
  void clear_telemetrylist();
  static const int kTelemetryListFieldNumber = 3;
  const ::TELEMETRY_CTRL::TelemetryList& telemetrylist() const;
  ::TELEMETRY_CTRL::TelemetryList* release_telemetrylist();
  ::TELEMETRY_CTRL::TelemetryList* mutable_telemetrylist();
  void set_allocated_telemetrylist(::TELEMETRY_CTRL::TelemetryList* telemetrylist);

  // optional .TELEMETRY_CTRL.SubscriberList subscriberList = 4;
  bool has_subscriberlist() const;
  void clear_subscriberlist();
  static const int kSubscriberListFieldNumber = 4;
  const ::TELEMETRY_CTRL::SubscriberList& subscriberlist() const;
  ::TELEMETRY_CTRL::SubscriberList* release_subscriberlist();
  ::TELEMETRY_CTRL::SubscriberList* mutable_subscriberlist();
  void set_allocated_subscriberlist(::TELEMETRY_CTRL::SubscriberList* subscriberlist);

  void clear_CommandData();
  CommandDataCase CommandData_case() const;
  // @@protoc_insertion_point(class_scope:TELEMETRY_CTRL.Ctrl)
 private:
  class HasBitSetters;
  void set_has_telemetrylist();
  void set_has_subscriberlist();

  inline bool has_CommandData() const;
  inline void clear_has_CommandData();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int msgtype_;
  int error_;
  union CommandDataUnion {
    CommandDataUnion() {}
    ::TELEMETRY_CTRL::TelemetryList* telemetrylist_;
    ::TELEMETRY_CTRL::SubscriberList* subscriberlist_;
  } CommandData_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_TelemetryCtrl_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Navigation

// required double latitude = 1;
inline bool Navigation::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Navigation::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Navigation::latitude() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Navigation.latitude)
  return latitude_;
}
inline void Navigation::set_latitude(double value) {
  _has_bits_[0] |= 0x00000001u;
  latitude_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Navigation.latitude)
}

// required double longitude = 2;
inline bool Navigation::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Navigation::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Navigation::longitude() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Navigation.longitude)
  return longitude_;
}
inline void Navigation::set_longitude(double value) {
  _has_bits_[0] |= 0x00000002u;
  longitude_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Navigation.longitude)
}

// required float altitude = 3;
inline bool Navigation::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Navigation::clear_altitude() {
  altitude_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Navigation::altitude() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Navigation.altitude)
  return altitude_;
}
inline void Navigation::set_altitude(float value) {
  _has_bits_[0] |= 0x00000004u;
  altitude_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Navigation.altitude)
}

// -------------------------------------------------------------------

// Orientation

// required float roll = 1;
inline bool Orientation::has_roll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Orientation::clear_roll() {
  roll_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Orientation::roll() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Orientation.roll)
  return roll_;
}
inline void Orientation::set_roll(float value) {
  _has_bits_[0] |= 0x00000001u;
  roll_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Orientation.roll)
}

// required float pitch = 2;
inline bool Orientation::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Orientation::clear_pitch() {
  pitch_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Orientation::pitch() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Orientation.pitch)
  return pitch_;
}
inline void Orientation::set_pitch(float value) {
  _has_bits_[0] |= 0x00000002u;
  pitch_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Orientation.pitch)
}

// required float yaw = 3;
inline bool Orientation::has_yaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Orientation::clear_yaw() {
  yaw_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Orientation::yaw() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Orientation.yaw)
  return yaw_;
}
inline void Orientation::set_yaw(float value) {
  _has_bits_[0] |= 0x00000004u;
  yaw_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Orientation.yaw)
}

// -------------------------------------------------------------------

// AirTelemetry

// optional float altBaro = 1;
inline bool AirTelemetry::has_altbaro() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AirTelemetry::clear_altbaro() {
  altbaro_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float AirTelemetry::altbaro() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.AirTelemetry.altBaro)
  return altbaro_;
}
inline void AirTelemetry::set_altbaro(float value) {
  _has_bits_[0] |= 0x00000001u;
  altbaro_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.AirTelemetry.altBaro)
}

// optional float airSpeed = 2;
inline bool AirTelemetry::has_airspeed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AirTelemetry::clear_airspeed() {
  airspeed_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AirTelemetry::airspeed() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.AirTelemetry.airSpeed)
  return airspeed_;
}
inline void AirTelemetry::set_airspeed(float value) {
  _has_bits_[0] |= 0x00000002u;
  airspeed_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.AirTelemetry.airSpeed)
}

// -------------------------------------------------------------------

// MRTelemetry

// optional float batteryVoltage = 1;
inline bool MRTelemetry::has_batteryvoltage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MRTelemetry::clear_batteryvoltage() {
  batteryvoltage_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MRTelemetry::batteryvoltage() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.MRTelemetry.batteryVoltage)
  return batteryvoltage_;
}
inline void MRTelemetry::set_batteryvoltage(float value) {
  _has_bits_[0] |= 0x00000001u;
  batteryvoltage_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.MRTelemetry.batteryVoltage)
}

// optional .TELEMETRY_CTRL.AutopilotMode autopilotMode = 2;
inline bool MRTelemetry::has_autopilotmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MRTelemetry::clear_autopilotmode() {
  autopilotmode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::TELEMETRY_CTRL::AutopilotMode MRTelemetry::autopilotmode() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.MRTelemetry.autopilotMode)
  return static_cast< ::TELEMETRY_CTRL::AutopilotMode >(autopilotmode_);
}
inline void MRTelemetry::set_autopilotmode(::TELEMETRY_CTRL::AutopilotMode value) {
  assert(::TELEMETRY_CTRL::AutopilotMode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  autopilotmode_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.MRTelemetry.autopilotMode)
}

// optional uint32 batteryChargePercent = 3;
inline bool MRTelemetry::has_batterychargepercent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MRTelemetry::clear_batterychargepercent() {
  batterychargepercent_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MRTelemetry::batterychargepercent() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.MRTelemetry.batteryChargePercent)
  return batterychargepercent_;
}
inline void MRTelemetry::set_batterychargepercent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  batterychargepercent_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.MRTelemetry.batteryChargePercent)
}

// -------------------------------------------------------------------

// Telemetry

// required uint32 boardId = 1;
inline bool Telemetry::has_boardid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Telemetry::clear_boardid() {
  boardid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Telemetry::boardid() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.boardId)
  return boardid_;
}
inline void Telemetry::set_boardid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  boardid_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.boardId)
}

// optional uint32 unix_time = 2;
inline bool Telemetry::has_unix_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Telemetry::clear_unix_time() {
  unix_time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Telemetry::unix_time() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.unix_time)
  return unix_time_;
}
inline void Telemetry::set_unix_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  unix_time_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.unix_time)
}

// optional .TELEMETRY_CTRL.Navigation gpsNavigation = 3;
inline bool Telemetry::has_gpsnavigation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Telemetry::clear_gpsnavigation() {
  if (gpsnavigation_ != nullptr) gpsnavigation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::TELEMETRY_CTRL::Navigation& Telemetry::gpsnavigation() const {
  const ::TELEMETRY_CTRL::Navigation* p = gpsnavigation_;
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.gpsNavigation)
  return p != nullptr ? *p : *reinterpret_cast<const ::TELEMETRY_CTRL::Navigation*>(
      &::TELEMETRY_CTRL::_Navigation_default_instance_);
}
inline ::TELEMETRY_CTRL::Navigation* Telemetry::release_gpsnavigation() {
  // @@protoc_insertion_point(field_release:TELEMETRY_CTRL.Telemetry.gpsNavigation)
  _has_bits_[0] &= ~0x00000001u;
  ::TELEMETRY_CTRL::Navigation* temp = gpsnavigation_;
  gpsnavigation_ = nullptr;
  return temp;
}
inline ::TELEMETRY_CTRL::Navigation* Telemetry::mutable_gpsnavigation() {
  _has_bits_[0] |= 0x00000001u;
  if (gpsnavigation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TELEMETRY_CTRL::Navigation>(GetArenaNoVirtual());
    gpsnavigation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.Telemetry.gpsNavigation)
  return gpsnavigation_;
}
inline void Telemetry::set_allocated_gpsnavigation(::TELEMETRY_CTRL::Navigation* gpsnavigation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gpsnavigation_;
  }
  if (gpsnavigation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gpsnavigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gpsnavigation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gpsnavigation_ = gpsnavigation;
  // @@protoc_insertion_point(field_set_allocated:TELEMETRY_CTRL.Telemetry.gpsNavigation)
}

// optional .TELEMETRY_CTRL.Orientation orientation = 4;
inline bool Telemetry::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Telemetry::clear_orientation() {
  if (orientation_ != nullptr) orientation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::TELEMETRY_CTRL::Orientation& Telemetry::orientation() const {
  const ::TELEMETRY_CTRL::Orientation* p = orientation_;
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.orientation)
  return p != nullptr ? *p : *reinterpret_cast<const ::TELEMETRY_CTRL::Orientation*>(
      &::TELEMETRY_CTRL::_Orientation_default_instance_);
}
inline ::TELEMETRY_CTRL::Orientation* Telemetry::release_orientation() {
  // @@protoc_insertion_point(field_release:TELEMETRY_CTRL.Telemetry.orientation)
  _has_bits_[0] &= ~0x00000002u;
  ::TELEMETRY_CTRL::Orientation* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::TELEMETRY_CTRL::Orientation* Telemetry::mutable_orientation() {
  _has_bits_[0] |= 0x00000002u;
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::TELEMETRY_CTRL::Orientation>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.Telemetry.orientation)
  return orientation_;
}
inline void Telemetry::set_allocated_orientation(::TELEMETRY_CTRL::Orientation* orientation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:TELEMETRY_CTRL.Telemetry.orientation)
}

// optional float gps_course = 5;
inline bool Telemetry::has_gps_course() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Telemetry::clear_gps_course() {
  gps_course_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Telemetry::gps_course() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.gps_course)
  return gps_course_;
}
inline void Telemetry::set_gps_course(float value) {
  _has_bits_[0] |= 0x00000040u;
  gps_course_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.gps_course)
}

// optional float gps_speed = 6;
inline bool Telemetry::has_gps_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Telemetry::clear_gps_speed() {
  gps_speed_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Telemetry::gps_speed() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.gps_speed)
  return gps_speed_;
}
inline void Telemetry::set_gps_speed(float value) {
  _has_bits_[0] |= 0x00000080u;
  gps_speed_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.gps_speed)
}

// optional .TELEMETRY_CTRL.AirTelemetry AirTelemetry = 7;
inline bool Telemetry::has_airtelemetry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Telemetry::clear_airtelemetry() {
  if (airtelemetry_ != nullptr) airtelemetry_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::TELEMETRY_CTRL::AirTelemetry& Telemetry::airtelemetry() const {
  const ::TELEMETRY_CTRL::AirTelemetry* p = airtelemetry_;
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.AirTelemetry)
  return p != nullptr ? *p : *reinterpret_cast<const ::TELEMETRY_CTRL::AirTelemetry*>(
      &::TELEMETRY_CTRL::_AirTelemetry_default_instance_);
}
inline ::TELEMETRY_CTRL::AirTelemetry* Telemetry::release_airtelemetry() {
  // @@protoc_insertion_point(field_release:TELEMETRY_CTRL.Telemetry.AirTelemetry)
  _has_bits_[0] &= ~0x00000004u;
  ::TELEMETRY_CTRL::AirTelemetry* temp = airtelemetry_;
  airtelemetry_ = nullptr;
  return temp;
}
inline ::TELEMETRY_CTRL::AirTelemetry* Telemetry::mutable_airtelemetry() {
  _has_bits_[0] |= 0x00000004u;
  if (airtelemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TELEMETRY_CTRL::AirTelemetry>(GetArenaNoVirtual());
    airtelemetry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.Telemetry.AirTelemetry)
  return airtelemetry_;
}
inline void Telemetry::set_allocated_airtelemetry(::TELEMETRY_CTRL::AirTelemetry* airtelemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete airtelemetry_;
  }
  if (airtelemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      airtelemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, airtelemetry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  airtelemetry_ = airtelemetry;
  // @@protoc_insertion_point(field_set_allocated:TELEMETRY_CTRL.Telemetry.AirTelemetry)
}

// optional .TELEMETRY_CTRL.MRTelemetry mrTelemetry = 8;
inline bool Telemetry::has_mrtelemetry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Telemetry::clear_mrtelemetry() {
  if (mrtelemetry_ != nullptr) mrtelemetry_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::TELEMETRY_CTRL::MRTelemetry& Telemetry::mrtelemetry() const {
  const ::TELEMETRY_CTRL::MRTelemetry* p = mrtelemetry_;
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.mrTelemetry)
  return p != nullptr ? *p : *reinterpret_cast<const ::TELEMETRY_CTRL::MRTelemetry*>(
      &::TELEMETRY_CTRL::_MRTelemetry_default_instance_);
}
inline ::TELEMETRY_CTRL::MRTelemetry* Telemetry::release_mrtelemetry() {
  // @@protoc_insertion_point(field_release:TELEMETRY_CTRL.Telemetry.mrTelemetry)
  _has_bits_[0] &= ~0x00000008u;
  ::TELEMETRY_CTRL::MRTelemetry* temp = mrtelemetry_;
  mrtelemetry_ = nullptr;
  return temp;
}
inline ::TELEMETRY_CTRL::MRTelemetry* Telemetry::mutable_mrtelemetry() {
  _has_bits_[0] |= 0x00000008u;
  if (mrtelemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::TELEMETRY_CTRL::MRTelemetry>(GetArenaNoVirtual());
    mrtelemetry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.Telemetry.mrTelemetry)
  return mrtelemetry_;
}
inline void Telemetry::set_allocated_mrtelemetry(::TELEMETRY_CTRL::MRTelemetry* mrtelemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete mrtelemetry_;
  }
  if (mrtelemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mrtelemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mrtelemetry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  mrtelemetry_ = mrtelemetry;
  // @@protoc_insertion_point(field_set_allocated:TELEMETRY_CTRL.Telemetry.mrTelemetry)
}

// optional .TELEMETRY_CTRL.FixType fixType = 9;
inline bool Telemetry::has_fixtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Telemetry::clear_fixtype() {
  fixtype_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::TELEMETRY_CTRL::FixType Telemetry::fixtype() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.fixType)
  return static_cast< ::TELEMETRY_CTRL::FixType >(fixtype_);
}
inline void Telemetry::set_fixtype(::TELEMETRY_CTRL::FixType value) {
  assert(::TELEMETRY_CTRL::FixType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  fixtype_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.fixType)
}

// optional uint32 satellitesCount = 10;
inline bool Telemetry::has_satellitescount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Telemetry::clear_satellitescount() {
  satellitescount_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Telemetry::satellitescount() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.satellitesCount)
  return satellitescount_;
}
inline void Telemetry::set_satellitescount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  satellitescount_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.satellitesCount)
}

// optional float mag_course = 11;
inline bool Telemetry::has_mag_course() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Telemetry::clear_mag_course() {
  mag_course_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Telemetry::mag_course() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.mag_course)
  return mag_course_;
}
inline void Telemetry::set_mag_course(float value) {
  _has_bits_[0] |= 0x00000400u;
  mag_course_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.mag_course)
}

// optional uint32 servo_angle = 12;
inline bool Telemetry::has_servo_angle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Telemetry::clear_servo_angle() {
  servo_angle_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Telemetry::servo_angle() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Telemetry.servo_angle)
  return servo_angle_;
}
inline void Telemetry::set_servo_angle(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  servo_angle_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Telemetry.servo_angle)
}

// -------------------------------------------------------------------

// TelemetryList

// repeated .TELEMETRY_CTRL.Telemetry list = 1;
inline int TelemetryList::list_size() const {
  return list_.size();
}
inline void TelemetryList::clear_list() {
  list_.Clear();
}
inline ::TELEMETRY_CTRL::Telemetry* TelemetryList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.TelemetryList.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TELEMETRY_CTRL::Telemetry >*
TelemetryList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:TELEMETRY_CTRL.TelemetryList.list)
  return &list_;
}
inline const ::TELEMETRY_CTRL::Telemetry& TelemetryList::list(int index) const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.TelemetryList.list)
  return list_.Get(index);
}
inline ::TELEMETRY_CTRL::Telemetry* TelemetryList::add_list() {
  // @@protoc_insertion_point(field_add:TELEMETRY_CTRL.TelemetryList.list)
  return list_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TELEMETRY_CTRL::Telemetry >&
TelemetryList::list() const {
  // @@protoc_insertion_point(field_list:TELEMETRY_CTRL.TelemetryList.list)
  return list_;
}

// -------------------------------------------------------------------

// SubscriberList

// repeated uint32 boardId = 1;
inline int SubscriberList::boardid_size() const {
  return boardid_.size();
}
inline void SubscriberList::clear_boardid() {
  boardid_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SubscriberList::boardid(int index) const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.SubscriberList.boardId)
  return boardid_.Get(index);
}
inline void SubscriberList::set_boardid(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  boardid_.Set(index, value);
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.SubscriberList.boardId)
}
inline void SubscriberList::add_boardid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  boardid_.Add(value);
  // @@protoc_insertion_point(field_add:TELEMETRY_CTRL.SubscriberList.boardId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
SubscriberList::boardid() const {
  // @@protoc_insertion_point(field_list:TELEMETRY_CTRL.SubscriberList.boardId)
  return boardid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
SubscriberList::mutable_boardid() {
  // @@protoc_insertion_point(field_mutable_list:TELEMETRY_CTRL.SubscriberList.boardId)
  return &boardid_;
}

// optional bool isSubscribeToAll = 2 [default = false];
inline bool SubscriberList::has_issubscribetoall() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriberList::clear_issubscribetoall() {
  issubscribetoall_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SubscriberList::issubscribetoall() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.SubscriberList.isSubscribeToAll)
  return issubscribetoall_;
}
inline void SubscriberList::set_issubscribetoall(bool value) {
  _has_bits_[0] |= 0x00000001u;
  issubscribetoall_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.SubscriberList.isSubscribeToAll)
}

// -------------------------------------------------------------------

// Ctrl

// required .TELEMETRY_CTRL.TelemetryCtrlMsgType msgType = 1;
inline bool Ctrl::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ctrl::clear_msgtype() {
  msgtype_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::TELEMETRY_CTRL::TelemetryCtrlMsgType Ctrl::msgtype() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Ctrl.msgType)
  return static_cast< ::TELEMETRY_CTRL::TelemetryCtrlMsgType >(msgtype_);
}
inline void Ctrl::set_msgtype(::TELEMETRY_CTRL::TelemetryCtrlMsgType value) {
  assert(::TELEMETRY_CTRL::TelemetryCtrlMsgType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  msgtype_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Ctrl.msgType)
}

// optional .TELEMETRY_CTRL.Error error = 2 [default = Error_NoError];
inline bool Ctrl::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ctrl::clear_error() {
  error_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::TELEMETRY_CTRL::Error Ctrl::error() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Ctrl.error)
  return static_cast< ::TELEMETRY_CTRL::Error >(error_);
}
inline void Ctrl::set_error(::TELEMETRY_CTRL::Error value) {
  assert(::TELEMETRY_CTRL::Error_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  error_ = value;
  // @@protoc_insertion_point(field_set:TELEMETRY_CTRL.Ctrl.error)
}

// optional .TELEMETRY_CTRL.TelemetryList telemetryList = 3;
inline bool Ctrl::has_telemetrylist() const {
  return CommandData_case() == kTelemetryList;
}
inline void Ctrl::set_has_telemetrylist() {
  _oneof_case_[0] = kTelemetryList;
}
inline void Ctrl::clear_telemetrylist() {
  if (has_telemetrylist()) {
    delete CommandData_.telemetrylist_;
    clear_has_CommandData();
  }
}
inline ::TELEMETRY_CTRL::TelemetryList* Ctrl::release_telemetrylist() {
  // @@protoc_insertion_point(field_release:TELEMETRY_CTRL.Ctrl.telemetryList)
  if (has_telemetrylist()) {
    clear_has_CommandData();
      ::TELEMETRY_CTRL::TelemetryList* temp = CommandData_.telemetrylist_;
    CommandData_.telemetrylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TELEMETRY_CTRL::TelemetryList& Ctrl::telemetrylist() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Ctrl.telemetryList)
  return has_telemetrylist()
      ? *CommandData_.telemetrylist_
      : *reinterpret_cast< ::TELEMETRY_CTRL::TelemetryList*>(&::TELEMETRY_CTRL::_TelemetryList_default_instance_);
}
inline ::TELEMETRY_CTRL::TelemetryList* Ctrl::mutable_telemetrylist() {
  if (!has_telemetrylist()) {
    clear_CommandData();
    set_has_telemetrylist();
    CommandData_.telemetrylist_ = CreateMaybeMessage< ::TELEMETRY_CTRL::TelemetryList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.Ctrl.telemetryList)
  return CommandData_.telemetrylist_;
}

// optional .TELEMETRY_CTRL.SubscriberList subscriberList = 4;
inline bool Ctrl::has_subscriberlist() const {
  return CommandData_case() == kSubscriberList;
}
inline void Ctrl::set_has_subscriberlist() {
  _oneof_case_[0] = kSubscriberList;
}
inline void Ctrl::clear_subscriberlist() {
  if (has_subscriberlist()) {
    delete CommandData_.subscriberlist_;
    clear_has_CommandData();
  }
}
inline ::TELEMETRY_CTRL::SubscriberList* Ctrl::release_subscriberlist() {
  // @@protoc_insertion_point(field_release:TELEMETRY_CTRL.Ctrl.subscriberList)
  if (has_subscriberlist()) {
    clear_has_CommandData();
      ::TELEMETRY_CTRL::SubscriberList* temp = CommandData_.subscriberlist_;
    CommandData_.subscriberlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TELEMETRY_CTRL::SubscriberList& Ctrl::subscriberlist() const {
  // @@protoc_insertion_point(field_get:TELEMETRY_CTRL.Ctrl.subscriberList)
  return has_subscriberlist()
      ? *CommandData_.subscriberlist_
      : *reinterpret_cast< ::TELEMETRY_CTRL::SubscriberList*>(&::TELEMETRY_CTRL::_SubscriberList_default_instance_);
}
inline ::TELEMETRY_CTRL::SubscriberList* Ctrl::mutable_subscriberlist() {
  if (!has_subscriberlist()) {
    clear_CommandData();
    set_has_subscriberlist();
    CommandData_.subscriberlist_ = CreateMaybeMessage< ::TELEMETRY_CTRL::SubscriberList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TELEMETRY_CTRL.Ctrl.subscriberList)
  return CommandData_.subscriberlist_;
}

inline bool Ctrl::has_CommandData() const {
  return CommandData_case() != COMMANDDATA_NOT_SET;
}
inline void Ctrl::clear_has_CommandData() {
  _oneof_case_[0] = COMMANDDATA_NOT_SET;
}
inline Ctrl::CommandDataCase Ctrl::CommandData_case() const {
  return Ctrl::CommandDataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TELEMETRY_CTRL

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TELEMETRY_CTRL::TelemetryCtrlMsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TELEMETRY_CTRL::TelemetryCtrlMsgType>() {
  return ::TELEMETRY_CTRL::TelemetryCtrlMsgType_descriptor();
}
template <> struct is_proto_enum< ::TELEMETRY_CTRL::Error> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TELEMETRY_CTRL::Error>() {
  return ::TELEMETRY_CTRL::Error_descriptor();
}
template <> struct is_proto_enum< ::TELEMETRY_CTRL::AutopilotMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TELEMETRY_CTRL::AutopilotMode>() {
  return ::TELEMETRY_CTRL::AutopilotMode_descriptor();
}
template <> struct is_proto_enum< ::TELEMETRY_CTRL::FixType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TELEMETRY_CTRL::FixType>() {
  return ::TELEMETRY_CTRL::FixType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TelemetryCtrl_2eproto
